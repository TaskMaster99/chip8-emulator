












#define INSTRUCTION_SET_SIZE 0X1000

void Chip8_load_instruction(Chip8_t* c)
{

    memset(INSTRUCTION_SET, 0, INSTRUCTION_SET_SIZE);

    INSTRUCTION_SET[0x00E0] = Instruction_00E0_CLS;
    INSTRUCTION_SET[0x00EE] = Instruction_00EE_RET;
    
    INSTRUCTION_SET[0x1000] = Instruction_1NNN_JP;
    INSTRUCTION_SET[0x2000] = Instruction_2NNN_CALL;
    INSTRUCTION_SET[0x3000] = Instruction_3XNN_SE;

    INSTRUCTION_SET[0x4000] = Instruction_4XNN_SNE;
    INSTRUCTION_SET[0x5000] = Instruction_5XY0_SE;
    INSTRUCTION_SET[0x6000] = Instruction_6XNN_LD;
    INSTRUCTION_SET[0x7000] = Instruction_7XNN_ADD;
    
    INSTRUCTION_SET[0x8000] = Instruction_8XY0_LD;
    INSTRUCTION_SET[0x8001] = Instruction_8XY1_OR;
    INSTRUCTION_SET[0x8002] = Instruction_8XY2_AND;
    INSTRUCTION_SET[0x8003] = Instruction_8XY3_XOR;
    INSTRUCTION_SET[0x8004] = Instruction_8XY4_ADD;
    INSTRUCTION_SET[0x8005] = Instruction_8XY5_SUB;
    INSTRUCTION_SET[0x8006] = Instruction_8XY6_SHR;
    INSTRUCTION_SET[0x8007] = Instruction_8XY7_SUBN;
    INSTRUCTION_SET[0x800E] = Instruction_8XYE_SHL;

    INSTRUCTION_SET[0x9000] = Instruction_9XY0_SNE;
    INSTRUCTION_SET[0xA000] = Instruction_ANNN_LD;
    INSTRUCTION_SET[0xB000] = Instruction_BNNN_AND;
    INSTRUCTION_SET[0xC000] = Instruction_CXNN_AND;
    INSTRUCTION_SET[0xD000] = Instruction_DXYN_DRW;

    INSTRUCTION_SET[0xE09E] = Instruction_EX9E_SKP;
    INSTRUCTION_SET[0xE0A1] = Instruction_EXA1_SKNP;

    INSTRUCTION_SET[0xF007] = Instruction_FX07_LD;
    INSTRUCTION_SET[0xF00A] = Instruction_FX0A_LD;
    INSTRUCTION_SET[0xF015] = Instruction_FX15_LD;
    INSTRUCTION_SET[0xF018] = Instruction_FX18_LD;
    INSTRUCTION_SET[0xF01E] = Instruction_FX1E_ADD;
    INSTRUCTION_SET[0xF029] = Instruction_FX29_LD;
    INSTRUCTION_SET[0xF033] = Instruction_FX33_LD;
    INSTRUCTION_SET[0xF055] = Instruction_FX55_LD;
    INSTRUCTION_SET[0xF065] = Instruction_FX65_LD;

}

Bit_mask_t BIT_MAP[0xF] = {

   { .ID = 0x0, .REMAINDER = 0x00FF },
   { .ID = 0x1, .REMAINDER = 0x8000 },
   { .ID = 0x2, .REMAINDER = 0x8000 },
   { .ID = 0x3, .REMAINDER = 0x8000 },
   { .ID = 0x4, .REMAINDER = 0x8000 },

   { .ID = 0x5, .REMAINDER = 0x8000 },
   { .ID = 0x6, .REMAINDER = 0x8000 },
   { .ID = 0x7, .REMAINDER = 0x8000 },
   { .ID = 0x8, .REMAINDER = 0x8001 },
   { .ID = 0x9, .REMAINDER = 0x8000 },

   { .ID = 0xA, .REMAINDER = 0x8000 },
   { .ID = 0xB, .REMAINDER = 0x8000 },
   { .ID = 0xC, .REMAINDER = 0x8000 },
   { .ID = 0xD, .REMAINDER = 0x8000 },
   { .ID = 0xE, .REMAINDER = 0x80FF },
   { .ID = 0xF, .REMAINDER = 0x80FF }
};


void Chip8_decode(Chip8_t* c, uint8_t* index)
{
    *index = BIT_MAP[c->CURRENT_INSTRUCTION.ID].ID << 8 |(c->CURRENT_INSTRUCTION.NNN & BIT_MAP[c->CURRENT_INSTRUCTION.ID].REMAINDER);
}

void Chip8_process_instruction(Chip8_t* c)
{
    Chip8_fetch(c);
    uint8_t index = c->CURRENT_INSTRUCTION.ID;

    Chip8_decode(c, &index);

    INSTRUCTION_SET[index](c);
    
}